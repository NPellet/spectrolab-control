var instruments; // All the instruments
var state; // Current state
var deviceProcedure, currentDeviceProcedure;

var renderer = require('app/renderer');
var experimentLoader = require('../../deviceprocedures/experimentloader');
var ITXBuilder = require("../../server/databuilder/itx").ITXBuilder;
var fileSaver = require("../../server/filesaver");
var path = require("path");
var events = require("events");

var config = require('../../server/config.js');
var fs = require('fs');
var extend = require('extend');
var stream = require('../../server/stream');

var deviceName;

stream.onGlobalMessage('experiment-run', function() {

	experimentLoader.runAll();
	stream.globalOut( "experiment-running" );
});

stream.onGlobalMessage('experiment-pause', function() {

	stream.globalOut( "experiment-pausing" );

	experimentLoader.pause().then( function() {
		stream.globalOut( "experiment-paused" );
	});

});

stream.onGlobalMessage('experiment-resume', function() {

	experimentLoader.resume();
	stream.globalOut( "experiment-running" );
});



stream.onGlobalMessage('experiment-abort', function() {

	stream.globalOut( "experiment-aborting" );

	experimentLoader.abort().then( function() {
		stream.globalOut( "experiment-stopped" );
	});
});


stream.onGlobalMessage("deviceName", function( d ) {
	deviceName = d;
});

stream.onGlobalMessage("domReady", function() {

	loadConfigList();
});

stream.onGlobalMessage( "modalOk", function() {

	experimentLoader.experimentLoopNext();
});

function loadConfigList() {

	var folder = exports.getExperimentFolder() + "/config";
	function readdirrec( folder, level ) {

		level = level || 0;

		if( ! fs.existsSync( folder ) ) {
			fs.mkdirSync( folder );
		}

		var arr = [],
			subArr;

		var files = fs.readdirSync( folder, level + 1 );

		for( var i = 0, l = files.length; i < l ; i ++ ) {

			subArr = {
				text: files[ i ],
				path: folder + "/" + files[ i ]
			};

			if( files[ i ] == 'default.json' && level == 0 ) {
					loadCfgFile( subArr.path );
					subArr.locked = true;
			}

			if( fs.lstatSync( folder + "/" + files[ i ] ).isDirectory() ) {
				subArr.nodes = readdirrec( folder + "/" + files[ i ] );
				subArr.selectable = false;
			}

			arr.push( subArr );
		}
		return arr;
	}

	var recfolder = [ { text: './', path: folder, nodes: readdirrec( folder ), selectable: false } ];

	stream.globalOut("cfg-list", recfolder );
}


stream.onGlobalMessage("cfg-load", function( load ) {

	loadCfgFile( load );

} );

function loadCfgFile( load ) {
	var cfgFile = {};
	try {
		cfgFile = JSON.parse( fs.readFileSync( load, 'utf-8' ) );
	} catch( e ) {
		console.warn("JSON not valid");
		cfgFile = {};
	}

	exports.config = cfgFile;
	exports.loadConfig();
}

stream.onGlobalMessage("cfg-save", function( name ) {

	fs.writeFileSync( ( ! fs.lstatSync( name.path ).isDirectory() ? path.dirname( name.path ) : name.path ) + "/" + name.file, JSON.stringify( exports.config ) );
	loadConfigList();
} );

stream.onGlobalMessage("cfg-newfolder", function( name ) {

	fs.mkdirSync( ( ! fs.lstatSync( name.path ).isDirectory() ? path.dirname( name.path ) : name.path ) + "/" + name.file );
	loadConfigList();
} );


stream.onGlobalMessage("cfg-remove", function( name ) {

	if( fs.lstatSync( name.path ).isDirectory() ) {
		fs.rmdirSync( name.path );
	} else {
		fs.unlinkSync( name.path );
	}

	loadConfigList();
} );



var loadCfg = new events.EventEmitter();

var exports = {

	/**
	 *	Load instruments into the experiment
	 *	@param {...string} instruments All the instruments to load
	 */
	loadInstruments: function( ) {

		if( typeof config != "object" ) {
			throw "Import instruments needs to load the config"
		}

		var toReturn = [];

		Array.prototype.shift.call( arguments );

		if( arguments.length == 0 ) {
			arguments = [];

			for( var i in config.instruments ) {

				var instr = require('../../controllers/' + config.instruments[ i ].type + '/default/controller' );
				var module = require('../../server/modules/instruments/' + config.instruments[ i ].type + '/connect/module' );

				toReturn[ i ] = {};
				toReturn[ i ].instrument = new instr( config.instruments[ i ] );
				toReturn[ i ].moduleName = 'instruments/' + config.instruments[ i ].type + '/connect';
				toReturn[ i ].moduleConstructor = module.Constructor;
			}
		}

		instruments = toReturn;
	},

	addInstrumentConnectModules: function() {
		renderer.setInstrumentsToWrapper( instruments, "control" );
	},

	/**
	 *
	 */

	/*
	sun: function( level ) {
		level = level || 0;
		instruments[ "arduino" ].setWhiteLightLevel( level );
		instruments[ "keithley-smu" ].writeDigioPin( 4, 1 );
	},

	sunOff: function( level ) {
		level = level || 0;
		instruments[ "arduino" ].setWhiteLightLevel( level );
		instruments[ "keithley-smu" ].writeDigioPin( 4, 1 );
	},

	iv: function( iv ) {

		return new Promise( function( resolver, rejecter ) {

		} );

		return instruments[ "keithley-smu" ].sweepIV( {

			channel: 'smub',
			settlingTime: 0.5,
			nbPoints: 30,
			startV: 1.1,
			stopV: 0,
			hysteresis: true,

		} ).then( function( iv ) {


		} );

	}*/


	/**
	 *	Returns the renderer. Must be set by the experiment
	 *	@return renderer
	 */
	getRenderer: function() {
		return renderer;
	},

	/**
	 * Returns the config json
	 *
	 */
	getConfig: function() {
		return config
	},

	getFileSaver: function() {
		return fileSaver;
	},

	getITXBuilder: function() {
		return ITXBuilder;
	},

	itx: function() {
		return new ITXBuilder();
	},

	getInstruments: function() {
		return instruments;
	},

	getInstrument: function( instrument ) {
		return instruments[ instrument ].instrument;
	},

	/**
	 *	Get device experiment procedure
	 *	@param {string} experimentName Experiment name
	 *	@return {object} experiment file
	 */
	 loadProcedure: function( experimentName, parameters ) {

	 	return experimentLoader.load( experimentName );

	 },

	 getProcedures: function() {
	 	return experimentLoader.getProcedures();
	 },

	 /**
	  *	Sets the current status of the measurement.
	  *	@param {object} stateToSet
	  */
	 setState: function( stateToSet ) {
	 	state = stateToSet;

	 	state.modules = {};
	 	renderer.allModules( function( module ) {

	 		state.modules[ module.getName() ] = module.getState();
	 	} );
	 },

	 /**
	  *	Gets the current status of the measurement
	  */
	 getState: function( ) {

	 	if( ! state ) {

	 		if( fs.fileExists( exports.getExperimentFolder() + "experiment_state.json" ) ) {

	 			//JSON.parse( )

	 		}
	 	}
	 	return state;
	 },

	 /**
	  *	Saves the current status of the measurement
	  */
	  saveState: function( ) {

		var fileInfo = fileSaver.save( {
			contents: JSON.stringify( state ),
			forceFileName: "experiment_state",
			fileExtension: 'json',
			dir: exports.getExperimentFolder()
		} );
	  },


	getConfig: function() {
  		return exports.config;
  	},

	getDeviceName: function() {
		return deviceName ||Â "NONAME";
	},

	// stream out API
	streamOut: function( messageTitle, messageContent ) {
		stream.globalOut( messageTitle, messageContent );
	},

	getModule: function() {
		return this.renderer.getModule.apply( this.renderer, arguments );
	},

	getExperimentFolder: function() {
		return this.experimentFolder;
	},

	setExperimentFolder: function( folder ) {
		this.experimentFolder = folder;
	},

	loadConfig: function( cfg ) {
		loadCfg.emit("config", cfg );
	},

	onLoadConfig: function( callback ) {
		return loadCfg.on("config", callback );
	}

}

module.exports = exports;
