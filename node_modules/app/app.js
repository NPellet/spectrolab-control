
var path = require("path");
var events = require("events");
var fs = require('fs');
var extend = require('extend');
var liquid = require("liquid-node"),
	lengine = new liquid.Engine;


var ITXBuilder = require("../../app/databuilder/itx").ITXBuilder;
var fileSaver = require("../../app/filesaver");

var appConfig = require('../../app/config.js');

var IO = require('../../app/stream');
var util = require("../../app/util");
var logger = require("../../app/logger");

var deviceName;
/*
IO.onGlobalMessage('experiment-run', function() {

	experimentLoader.runAll();
	IO.globalOut( "experiment-running" );
});

IO.onGlobalMessage('experiment-pause', function() {

	IO.globalOut( "experiment-pausing" );

	experimentLoader.pause().then( function() {
		IO.globalOut( "experiment-paused" );
	});

});

IO.onGlobalMessage('experiment-resume', function() {

	experimentLoader.resume();
	IO.globalOut( "experiment-running" );
});



IO.onGlobalMessage('experiment-abort', function() {

	IO.globalOut( "experiment-aborting" );

	experimentLoader.abort().then( function() {
		IO.globalOut( "experiment-stopped" );
	});
});


IO.onGlobalMessage("deviceName", function( d ) {
	deviceName = d;
});


IO.onGlobalMessage( "modalOk", function() {

	experimentLoader.experimentLoopNext();
});

*/

var renderLeftPannel = function() {

	return lengine.parseAndRender( fs.readFileSync( './app/html/leftpannel.html'), exports.getTplData() ).then( function( html ) {
		IO.globalOut("updateleftpannel", html );
	} );

}


var loadCfg = new events.EventEmitter();

var exports = {


	/**
	 *	Returns the renderer. Must be set by the experiment
	 *	@return renderer
	 */
	getRenderer: function() {
		return renderer;
	},

	setRenderer: function( r ) {
		renderer = r;


	//	main( {}, exports, renderer );

	},

	/**
	 * Returns the config json
	 */
	getConfig: function() {

		return appConfig;
	},

	saveConfig: function() {
		fs.writeFile( "./app/config.js", " module.exports = " + JSON.stringify( appConfig, null, "\t" ) + ";", 'utf8', function( err ) {

			if( err ) throw err;
			
		} );
	},

	getFileSaver: function() {
		return fileSaver;
	},

	itx: function() {
		return new ITXBuilder();
	},

	save: function( folder, content, name, extension ) {
       	
		this.getFileSaver().save( {

			contents: content,
			forceFileName: name + "." + extension,
			fileExtension: extension,
			dir: folder
		} );
	},

	getInstruments: function() {
		return instrumentInstances;
	},

	getInstrument: function( instrument ) {
		return instrumentInstances[ instrument ];
	},

	/**
	 *	Get device experiment procedure
	 *	@param {string} experimentName Experiment name
	 *	@return {object} experiment file
	 */
	 loadProcedure: function( experimentName, parameters ) {

	 	return experimentLoader.load( experimentName );

	 },

	 getProcedures: function() {
	 	return experimentLoader.getProcedures();
	 },

	 /**
	  *	Sets the current status of the measurement.
	  *	@param {object} stateToSet
	  */
	 setState: function( stateToSet ) {
	 	state = stateToSet;

	 	state.modules = {};
	 	renderer.allModules( function( module ) {

	 		state.modules[ module.getName() ] = module.getState();
	 	} );
	 },

	 /**
	  *	Gets the current status of the measurement
	  */
	 getState: function( ) {

	 	if( ! state ) {

	 		if( fs.fileExists( exports.getExperimentFolder() + "experiment_state.json" ) ) {

	 			//JSON.parse( )

	 		}
	 	}
	 	return state;
	 },

	 /**
	  *	Saves the current status of the measurement
	  */
	  saveState: function( ) {

		var fileInfo = fileSaver.save( {
			contents: JSON.stringify( state ),
			forceFileName: "experiment_state",
			fileExtension: 'json',
			dir: exports.getExperimentFolder()
		} );
	  },


	getDeviceName: function() {
		return deviceName ||Â "NONAME";
	},

	// stream out API
	streamOut: function( messageTitle, messageContent ) {
		IO.globalOut( messageTitle, messageContent );
	},

	getModule: function() {
		return this.renderer.getModule.apply( this.renderer, arguments );
	},

	getExperimentFolder: function() {
		return this.experimentFolder;
	},

	setExperimentFolder: function( folder ) {
		this.experimentFolder = folder;
	},

	loadConfig: function( cfg ) {
		loadCfg.emit("config", cfg );
	},

	onLoadConfig: function( callback ) {
		return loadCfg.on("config", callback );
	},

	getLogger: function() {
		return logger;
	}

};


exports.getMethodConfigurationForm = function( methodPath ) {

	
}


exports.getTplData = function() {

	return {
		ip: util.getIp(),
		config: appConfig,
		methods: methods,
		devices: devices,
		instruments: instruments
	}
};


module.exports = exports;



IO.onGlobalMessage( "loggerGetMessages", function() {

	logger.getMessages();
} )

var devices = ( function() {

	var availableDevices = appConfig.devices;
	var usedDevices = [];

	usedDevices = extend( true, usedDevices, availableDevices );

	usedDevices.map( function( device ) {
		device.selected = false;
	})

	IO.onGlobalMessage( "selectDevice", function( devicePosition ) {

		for( var i = 0, l = usedDevices.length; i < l; i ++ ) {
			if( usedDevices[ i ].position == devicePosition ) {
				usedDevices[ i ].selected = true;
				break;
			}
		}


		renderLeftPannel();
	});

	IO.onGlobalMessage( "unselectDevice", function( devicePosition ) {

		for( var i = 0, l = usedDevices.length; i < l; i ++ ) {
			if( usedDevices[ i ].position == devicePosition ) {
				usedDevices[ i ].selected = false;
				break;
			}
		}

		renderLeftPannel();
	});

	return usedDevices;
}) ();

var methods = ( function() {

	var flatMethods = [];
	var usedMethods = [];

	IO.onGlobalMessage( "getmethodconfiguration", function( d ) {

		lengine.parseAndRender( fs.readFileSync( d.method + "/configform.html" ), exports.getTplData() ).then( function( data ) {

			var fill;
			for( var i = 0, l = usedMethods.length; i < l ; i ++ ) {
				if( usedMethods[ i ].id == d.methodid ) {
					fill = usedMethods[ i ].config;
					break;
				}
			}
			
			IO.globalOut( "methodconfiguration", { form: data, fill: fill } );

		});

	} );


	IO.onGlobalMessage( "configuremethod", function( d ) {

		if( d.methodid ) {

			for( var i = 0, l = usedMethods.length; i < l ; i ++ ) {
				if( methods[ i ].id == d.methodid ) {
					method = usedMethods[ i ];
					break;
				}
			}
		} else {


			var method = {
				id: util.guid(),
				path: d.method,
			};

			for( var i = 0, l = flatMethods.length; i < l; i ++ ) {

				if( d.method == flatMethods[ i ].path ) {
					method.name = flatMethods[ i ].text;
					method._device = flatMethods[ i ]._device;
				}
			}
		}

		method.config = d.configuration;

		if( ! d.methodid ) {
			usedMethods.push( method );
			renderLeftPannel();
		}

	} );


	
	function readdirrec( folder, text, mask ) {

		if( text == "_ignore" ) {
			return;
		}

		if( ! fs.existsSync( folder ) ) {
			fs.mkdirSync( folder );
		}

		var	subArr = {
			  text: text,
			  path: folder
			},
			files = fs.readdirSync( folder );

		for( var i = 0, l = files.length; i < l ; i ++ ) {

			if( files[ i ] == 'config.json' ) {
			//	loadCfgFile( subArr.path );

				subArr.text = JSON.parse( fs.readFileSync( folder + "/" + files[ i ] ) ).name;
				subArr.nodes = false;

				if( mask ) {
					subArr._device = true;
				} else {
					subArr._device = false;
				}

				flatMethods.push( subArr );

				return subArr;
			}

			if( fs.lstatSync( folder + "/" + files[ i ] ).isDirectory() ) {
				subArr.nodes = subArr.nodes || [];

				var sub = readdirrec( folder + "/" + files[ i ], files[ i ], mask );

				if( sub ) {
					subArr.nodes.push( sub );
				}
			}
		}

		if( subArr.nodes && subArr.nodes.length > 0 ) {
			return subArr;
		}

		return false;
	}

	var recursiveMethodsDevices = readdirrec( "./experiments/devices", "", true ).nodes;
	var recursiveMethodsNonDevices = readdirrec( "./experiments/non-devices", "", false ).nodes;

	IO.onGlobalMessage("domReady", function( nothing, ws ) {
		
		IO.globalOut( "method-list-devices", recursiveMethodsDevices, ws );
		IO.globalOut( "method-list-nondevices", recursiveMethodsNonDevices, ws );
	});


	return usedMethods;

}) ();


IO.onGlobalMessage("experiment-run", function() {

	var methodMasked = [];
	var devicesMasked = [];

	// First we get the methods that are device independant
	methods.map( function( method ) {
		if( ! method._device ) {
			methodMasked.push( method );
		}
	} );

// First we get the methods that are device independant
	devices.map( function( device ) {
		if( device.selected ) {
			devicesMasked.push( device );
		}
	} );


	runMethods( methodMasked ).then( function() {

		// Now we can run the other methods
		methodMasked = [];

		// First we get the methods that are device independant
		methods.map( function( method ) {
			if( method._device ) {
				methodMasked.push( method );
			}
		} );


		return runMethodsDevices( methodMasked, devicesMasked );
	});

});

function runMethodsDevices( methods, devices ) {

	if( devices.length == 0 ) {
		return new Promise( function( resolver, rejecter ) { resolver(); } )
	}

	var device;
	do {
		device = devices.shift();
		if( ! device ) {
			return new Promise( function( resolver, rejecter ) { resolver (); } )
		}
	} while( ! device.selected );
	//return exporting.goToDevice( device ).then( function() {

		return runMethods( methods, device ).then( function() {
			return runMethodsDevices( methods, devices );
		} );
	//} );

}

function runMethods( methods, device ) {

	if( methods.length == 0 ) {
		return new Promise( function( resolver, rejecter ) { resolver(); } );
	}

	var method = methods.shift();
console.log( method );
	return runMethod( method ).then( function() {
		return runMethods( methods, devices );
	} );
}

	var main = require( "../../experiments/devices/qextraction_voc/server.js" );	
	var client = require( "../../experiments/devices/qextraction_voc/client.js" );


function runMethod( method ) {

	var main = require( "../../" + method.path + "/server.js" );	
	var client = require( "../../" + method.path + "/client.js" );

	renderer.renderGrid( client );
	return main( method.config, exports, renderer );
}

IO.onGlobalMessage("domReady", function( nothing, ws ) {
	
	// Pick up the current experiment if just connected
	renderer.renderGrid( false, ws );
});


// Client has parsed the modules, time to render them !
IO.onGlobalMessage("modulesReady", function( nothing, ws ) {	
	renderer.modulesReady( ws );
} );



var instrumentInstances = {};
var instruments = ( function() {

	var availableInstruments = appConfig.instruments;
	var usedInstruments = {};

	extend( true, usedInstruments, availableInstruments );

	for( var i in usedInstruments ) {

		var instr = require('../../controllers/' + usedInstruments[ i ].type + '/default/controller' );
		instrumentInstances[ i ] = new instr( usedInstruments[ i ] );
		instrumentInstances[ i ].setName( usedInstruments[ i ].name );
		
		usedInstruments[ i ].connected = false;
		usedInstruments[ i ].error = false;
		usedInstruments[ i ].connecting = false;


		( function( usedInstrument, usedInstrumentInstance ) {


			usedInstrumentInstance.on( "connected", function() {
				
				usedInstrument.connected = true;
				usedInstrument.connecting = false;
				usedInstrument.error = false;

				renderLeftPannel();
			} );



			usedInstrumentInstance.on( "connecting", function() {
				
				usedInstrument.connected = false;
				usedInstrument.connecting = true;
				usedInstrument.error = false;

				renderLeftPannel();
			} );


			usedInstrumentInstance.on( "disconnected", function() {
				usedInstrument.connected = false;
				usedInstrument.connecting = false;
				usedInstrument.error = false;

				renderLeftPannel();
			} );


			usedInstrumentInstance.on( "connectionerror", function() {
				usedInstrument.connected = false;
				usedInstrument.connecting = false;
				usedInstrument.error = true;

				renderLeftPannel();
			} );

		}) ( usedInstruments[ i ], instrumentInstances[ i ] );

	}

	IO.onGlobalMessage( "connectInstrument", function( instrumentId ) {

		exports.getInstrument( instrumentId ).connect();
	});

	return usedInstruments;

}) ();







function loadConfigList() {

	var folder = "methodlists";
	function readdirrec( folder, level ) {

		level = level || 0;

		if( ! fs.existsSync( folder ) ) {
			fs.mkdirSync( folder );
		}

		var arr = [],
			subArr;

		var files = fs.readdirSync( folder, level + 1 );

		for( var i = 0, l = files.length; i < l ; i ++ ) {

			subArr = {
				text: files[ i ],
				path: folder + "/" + files[ i ]
			};

			
			if( fs.lstatSync( folder + "/" + files[ i ] ).isDirectory() ) {
				subArr.nodes = readdirrec( folder + "/" + files[ i ] );
				subArr.selectable = false;
			}

			arr.push( subArr );
		}
		return arr;
	}

	var recfolder = [ { text: './', path: folder, nodes: readdirrec( folder ), selectable: false } ];

	IO.globalOut("methodslists", recfolder );
}


IO.onGlobalMessage("loadmethodslists", function( load ) {

	loadConfigList( );

} );

function loadCfgFile( load ) {
	var cfgFile = {};


	try {
		cfgFile = JSON.parse( fs.readFileSync( load, 'utf-8' ) );
	} catch( e ) {
		console.warn("JSON not valid");
		cfgFile = {};
	}

	exports.config = cfgFile;
	exports.loadConfig();
}

IO.onGlobalMessage("cfg-save", function( name ) {

	fs.writeFileSync( ( ! fs.lstatSync( name.path ).isDirectory() ? path.dirname( name.path ) : name.path ) + "/" + name.file, JSON.stringify( exports.config ) );
	loadConfigList();
} );

IO.onGlobalMessage("cfg-newfolder", function( name ) {

	fs.mkdirSync( ( ! fs.lstatSync( name.path ).isDirectory() ? path.dirname( name.path ) : name.path ) + "/" + name.file );
	loadConfigList();
} );


IO.onGlobalMessage("cfg-remove", function( name ) {

	if( fs.lstatSync( name.path ).isDirectory() ) {
		fs.rmdirSync( name.path );
	} else {
		fs.unlinkSync( name.path );
	}

	loadConfigList();
} );


