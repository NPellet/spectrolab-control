
var path = require("path");
var events = require("events");
var fs = require('fs');
var extend = require('extend');
var liquid = require("liquid-node"),
	lengine = new liquid.Engine;


var appConfig = require('../../app/config.js'),
	ITXBuilder = require("../../app/databuilder/itx").ITXBuilder,
	fileSaver = require("../../app/filesaver"),
	IO = require('../../app/stream'),
	util = require("../../app/util"),
	logger = require("../../app/logger");

var state = {};
var serverState = {};

var exports = {


	/**
	 *	Returns the renderer. Must be set by the experiment
	 *	@return renderer
	 */
	getRenderer: function() {
		return renderer;
	},

	setRenderer: function( r ) {
		renderer = r;


	//	main( {}, exports, renderer );

	},

	/**
	 * Returns the config json
	 */
	getConfig: function() {

		return appConfig;
	},

	saveConfig: function() {
		fs.writeFile( "./app/config.js", " module.exports = " + JSON.stringify( appConfig, null, "\t" ) + ";", 'utf8', function( err ) {

			if( err ) throw err;
			
		} );
	},

	getFileSaver: function() {
		return fileSaver;
	},

	itx: function() {
		return new ITXBuilder();
	},

	save: function( folder, content, extension ) {
       	
		this.getFileSaver().save( {

			contents: content,
			forceFileName: pad( methodTime.getHours() ) + ":" + pad( methodTime.getMinutes() ) + ":" + pad( methodTime.getSeconds() ) + "_" + getCurrentDeviceName() + "." + extension,
			fileExtension: extension,
			dir: folder
		} );
	},

	getInstruments: function() {
		return instrumentInstances;
	},

	getInstrument: function( instrument ) {
		return instrumentInstances[ instrument ];
	},

	// stream out API
	streamOut: function( messageTitle, messageContent ) {
		IO.globalOut( messageTitle, messageContent );
	},

	getModule: function() {
		return this.renderer.getModule.apply( this.renderer, arguments );
	},

	getLogger: function() {
		return logger;
	}

};


function renderLeftPannel() {

	return lengine.parseAndRender( fs.readFileSync( './app/html/leftpannel.html'), exports.getTplData() ).then( function( html ) {
		IO.globalOut("updateleftpannel", html );
	} );

}


var loadCfg = new events.EventEmitter();



function pad( num ) {
	return ( num + "" ).length == 1 ? "0" + num : num;
}


exports.getMethodConfigurationForm = function( methodPath ) {

	
}


exports.getTplData = function() {

	return {
		ip: util.getIp(),
		config: appConfig,
		methods: methods,
		devices: devices,
		instruments: instruments
	}
};

exports.ready = function() {

	return Promise.all( [].map.call( arguments, function( instrument ) { 
		
		return instrument.ready; 
	} ) );
}


exports.wait = function( timer ) {

	return new Promise( function( resolver, rejecter ) {

		setTimeout( function() {

			resolver();
			
		}, timer * 1000 );
	})
}

module.exports = exports;



IO.onGlobalMessage( "loggerGetMessages", function() {

	logger.getMessages();
} );


var currentDevice;

function getCurrentDeviceName() {
	return currentDevice.name;
}


var devices = ( function() {

	var availableDevices = appConfig.devices;
	var usedDevices = [];

	usedDevices = extend( true, usedDevices, availableDevices );

	usedDevices.map( function( device ) {
		device.selected = false;
	})

	IO.onGlobalMessage( "selectDevice", function( devicePosition ) {

		for( var i = 0, l = usedDevices.length; i < l; i ++ ) {
			if( usedDevices[ i ].position == devicePosition ) {
				usedDevices[ i ].selected = true;
				break;
			}
		}


		renderLeftPannel();
	});

	IO.onGlobalMessage( "unselectDevice", function( devicePosition ) {

		for( var i = 0, l = usedDevices.length; i < l; i ++ ) {
			if( usedDevices[ i ].position == devicePosition ) {
				usedDevices[ i ].selected = false;
				break;
			}
		}

		renderLeftPannel();
	});

	IO.onGlobalMessage( "devicename", function( device ) {

		for( var i = 0, l = usedDevices.length; i < l; i ++ ) {
			if( usedDevices[ i ].position == device.position ) {
				usedDevices[ i ].name = device.name;
				break;
			}
		}

		renderLeftPannel();
	});

	return usedDevices;
}) ();

var methods = ( function() {

	var flatMethods = [];
	var usedMethods = [];

	IO.onGlobalMessage( "getmethodconfiguration", function( d ) {

		lengine.parseAndRender( fs.readFileSync( d.method + "/configform.html" ), exports.getTplData() ).then( function( data ) {

			var fill;
			for( var i = 0, l = usedMethods.length; i < l ; i ++ ) {
				if( usedMethods[ i ].id == d.methodid ) {
					fill = usedMethods[ i ].config;
					break;
				}
			}
			
			IO.globalOut( "methodconfiguration", { form: data, fill: fill } );

		});

	} );




	IO.onGlobalMessage( "erasemethods", function( ) {

		flatMethods.length = 0;
		usedMethods.length = 0;
		
		renderLeftPannel();

	} );




	IO.onGlobalMessage("loadmethods", function( name ) {
		
		var json = JSON.parse( fs.readFileSync( name ) );

		if( Array.isArray( json ) ) {

			usedMethods.length = 0;

			json.map( function( j ) {
				usedMethods.push( j );
			} );

			renderLeftPannel();
		}
	} );

	IO.onGlobalMessage("savemethods", function( name ) {

		fs.writeFileSync( ( ! fs.lstatSync( name.path ).isDirectory() ? path.dirname( name.path ) : name.path ) + "/" + name.file, JSON.stringify( usedMethods ) );
		loadConfigList();
	} );


	IO.onGlobalMessage("newfoldermethods", function( name ) {

		fs.mkdirSync( ( ! fs.lstatSync( name.path ).isDirectory() ? path.dirname( name.path ) : name.path ) + "/" + name.file );
		loadConfigList();
	} );


	IO.onGlobalMessage("removemethods", function( name ) {

		if( fs.lstatSync( name.path ).isDirectory() ) {
			fs.rmdirSync( name.path );
		} else {
			fs.unlinkSync( name.path );
		}

		loadConfigList();
	} );



	IO.onGlobalMessage( "configuremethod", function( d ) {

		if( d.methodid ) {

			for( var i = 0, l = usedMethods.length; i < l ; i ++ ) {
				if( methods[ i ].id == d.methodid ) {
					method = usedMethods[ i ];
					break;
				}
			}
		} else {


			var method = {
				id: util.guid(),
				path: d.method,
			};

			for( var i = 0, l = flatMethods.length; i < l; i ++ ) {

				if( d.method == flatMethods[ i ].path ) {
					method.name = flatMethods[ i ].text;
					method._device = flatMethods[ i ]._device;
				}
			}
		}

		method.config = d.configuration;

		if( ! d.methodid ) {
			usedMethods.push( method );
			renderLeftPannel();
		}

	} );



	
	function readdirrec( folder, text, mask ) {

		if( text == "_ignore" ) {
			return;
		}

		if( ! fs.existsSync( folder ) ) {
			fs.mkdirSync( folder );
		}

		var	subArr = {
			  text: text,
			  path: folder
			},
			files = fs.readdirSync( folder );

		for( var i = 0, l = files.length; i < l ; i ++ ) {

			if( files[ i ] == 'config.json' ) {
			//	loadCfgFile( subArr.path );

				subArr.text = JSON.parse( fs.readFileSync( folder + "/" + files[ i ] ) ).name;
				subArr.nodes = false;

				if( mask ) {
					subArr._device = true;
				} else {
					subArr._device = false;
				}

				flatMethods.push( subArr );

				return subArr;
			}

			if( fs.lstatSync( folder + "/" + files[ i ] ).isDirectory() ) {
				subArr.nodes = subArr.nodes || [];

				var sub = readdirrec( folder + "/" + files[ i ], files[ i ], mask );

				if( sub ) {
					subArr.nodes.push( sub );
				}
			}
		}

		if( subArr.nodes && subArr.nodes.length > 0 ) {
			return subArr;
		}

		return false;
	}

	var recursiveMethodsDevices = readdirrec( "./experiments/devices", "", true ).nodes;
	var recursiveMethodsNonDevices = readdirrec( "./experiments/non-devices", "", false ).nodes;

	IO.onGlobalMessage("domReady", function( nothing, ws ) {
		
		IO.globalOut( "method-list-devices", recursiveMethodsDevices, ws );
		IO.globalOut( "method-list-nondevices", recursiveMethodsNonDevices, ws );
	});


	return usedMethods;

}) ();


IO.onGlobalMessage("experiment-run", function() {

	var methodMasked = [];
	var devicesMasked = [];

	// First we get the methods that are device independant
	methods.map( function( method ) {
		if( ! method._device ) {
			methodMasked.push( method );
		}
	} );

// First we get the methods that are device independant
	devices.map( function( device ) {
		if( device.selected ) {
			devicesMasked.push( device );
		}
	} );


	runMethods( methodMasked ).then( function() {

		logger.info("Non-device methods terminated. Running device methods...");
		// Now we can run the other methods
		methodMasked = [];

		// First we get the methods that are device independant
		methods.map( function( method ) {
			if( method._device ) {
				methodMasked.push( method );
			}
		} );


		return runMethodsDevices( methodMasked, devicesMasked ).then( function() {

			logger.ok("Finished measurement !");

		} );
	} );
} );

function runMethodsDevices( methods, devices ) {

	if( devices.length == 0 ) {
		return new Promise( function( resolver, rejecter ) { resolver(); } )
	}

	var device;
	do {
		device = devices.shift();
		if( ! device ) {
			return new Promise( function( resolver, rejecter ) { resolver (); } )
		}
	} while( ! device.selected );
	//return exporting.goToDevice( device ).then( function() {

	currentDevice = device;

	return runMethods( methods, device ).then( function() {
		return runMethodsDevices( methods, devices );
	} );
	//} );

}

function runMethods( methods, device ) {

	if( methods.length == 0 ) {
		return new Promise( function( resolver, rejecter ) { resolver(); } );
	}

	var method = methods.shift();

	return runMethod( method ).then( function() {

		if( methods.length > 0 ) {

			return showModal( "Method done", "Method " + method.name + " done. Continue with next procedure in...", "Continue now", 30 ).then( function() {
				return runMethods( methods, devices );
			} );
		};

		return this;
	} );
}

var main = require( "../../experiments/devices/transients/tpv_slow/server.js" );	
var client = require( "../../experiments/devices/transients/tpv_slow/client.js" );


function runMethod( method ) {

	var main = require( "../../" + method.path + "/server.js" );	
	var client = require( "../../" + method.path + "/client.js" );

	state.method = method.id;
	exportState();

	renderer.renderGrid( client );

	methodTime = new Date();

	method.running = true;

	renderLeftPannel();

	return main( method.config, exports, renderer ).then( function() {
		method.running = false;
	});
}

IO.onGlobalMessage("domReady", function( nothing, ws ) {
	
	// Pick up the current experiment if just connected
	renderer.renderGrid( false, ws );
});


// Client has parsed the modules, time to render them !
IO.onGlobalMessage("modulesReady", function( nothing, ws ) {	
	renderer.modulesReady( ws );
} );



var instrumentInstances = {};
var instruments = ( function() {

	var availableInstruments = appConfig.instruments;
	var usedInstruments = {};

	extend( true, usedInstruments, availableInstruments );

	for( var i in usedInstruments ) {

		var instr = require('../../controllers/' + usedInstruments[ i ].type + '/default/controller' );
		instrumentInstances[ i ] = new instr( usedInstruments[ i ] );
		instrumentInstances[ i ].setName( usedInstruments[ i ].name );
		instrumentInstances[ i ].init( usedInstruments[ i ] );
		
		usedInstruments[ i ].connected = false;
		usedInstruments[ i ].error = false;
		usedInstruments[ i ].connecting = false;

		( function( usedInstrument, usedInstrumentInstance ) {

			usedInstrumentInstance.on( "connected", function() {
				
				usedInstrument.connected = true;
				usedInstrument.connecting = false;
				usedInstrument.error = false;

				renderLeftPannel();
			} );



			usedInstrumentInstance.on( "connecting", function() {
				
				usedInstrument.connected = false;
				usedInstrument.connecting = true;
				usedInstrument.error = false;

				renderLeftPannel();
			} );


			usedInstrumentInstance.on( "disconnected", function() {
				usedInstrument.connected = false;
				usedInstrument.connecting = false;
				usedInstrument.error = false;

				renderLeftPannel();
			} );


			usedInstrumentInstance.on( "connectionerror", function() {
				usedInstrument.connected = false;
				usedInstrument.connecting = false;
				usedInstrument.error = true;

				renderLeftPannel();
			} );

		}) ( usedInstruments[ i ], instrumentInstances[ i ] );

	}

	IO.onGlobalMessage( "connectInstrument", function( instrumentId ) {

		exports.getInstrument( instrumentId ).connect();
	});

/*
	exports.getInstrument('arduinoDigio').connect().then( function( ) {

		setTimeout( function() {
			exports.getInstrument('arduinoDigio').setDigital( 32, 1 );	
			exports.getInstrument('arduinoDigio').setDigital( 24, 1 );	
			exports.getInstrument('arduinoDigio').setDigital( 22, 1 );	
			exports.getInstrument('arduinoDigio').setDigital( 26, 1 );	
			exports.getInstrument('arduinoDigio').setDigital( 28, 1 );	
			exports.getInstrument('arduinoDigio').setDigital( 30, 1 );	
		}, 1000)
		

	});
*/
	return usedInstruments;

}) ();



function loadConfigList() {

	var folder = "methodlists";
	function readdirrec( folder, level ) {

		level = level || 0;

		if( ! fs.existsSync( folder ) ) {
			fs.mkdirSync( folder );
		}

		var arr = [],
			subArr;

		var files = fs.readdirSync( folder, level + 1 );

		for( var i = 0, l = files.length; i < l ; i ++ ) {

			subArr = {
				text: files[ i ],
				path: folder + "/" + files[ i ]
			};

			
			if( fs.lstatSync( folder + "/" + files[ i ] ).isDirectory() ) {
				subArr.nodes = readdirrec( folder + "/" + files[ i ] );
				subArr.selectable = false;
			}

			arr.push( subArr );
		}
		return arr;
	}

	var recfolder = [ { text: './', path: folder, nodes: readdirrec( folder ), selectable: false } ];

	IO.globalOut("methodslists", recfolder );
}


IO.onGlobalMessage("loadmethodslists", function( load ) {

	loadConfigList( );

} );

function loadCfgFile( load ) {
	var cfgFile = {};


	try {
		cfgFile = JSON.parse( fs.readFileSync( load, 'utf-8' ) );
	} catch( e ) {
		console.warn("JSON not valid");
		cfgFile = {};
	}

	exports.config = cfgFile;
	exports.loadConfig();
}



showModal = function( title, text, buttonText, countdown ) {

	if( state.modal ) {
		throw "Cannot open a new modal";
	}


	state.modal = { 
		title: title,
		text: text,
		buttonText: buttonText,
		timer: Date.now(),
		countdown: countdown
	}

	return new Promise( function( resolver, rejecter ) {

		serverState.modal = {};
		serverState.modal.resolver = resolver;

		if( countdown ) {

			serverState.modal.timeout = setTimeout( function() {
				
				resolver();

				state.modal = false;
				serverState.modal = false;

				exportState();

			}, countdown * 1000 );
		}

		exportState();
	} );
}

function exportState( ws ) {

	if( state.modal ) {
		state.modal.remaining = state.modal.countdown - ( Date.now() - state.modal.timer ) / 1000; // Remaining time for info
	}

	IO.globalOut( "state", state, ws );
}

IO.onGlobalMessage( "modalOk", function() {

	if( state.modal ) {

		serverState.modal.resolver();

		if( serverState.modal.timeout ) {
			clearTimeout( severState.modal.timeout );
		}

		state.modal = false;
		serverState.modal = false;
	}
})

IO.onGlobalMessage( "getState", function( ws ) {

	exportState( ws );
} );
